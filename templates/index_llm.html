<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traducteur Vocal Minimaliste</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .progress-bar {
            height: 2px;
            background-color: #000;
            transition: width 0.3s ease;
        }
        
        .recording {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body class="bg-white text-black min-h-screen flex flex-col items-center justify-center p-8">
    <div class="w-full max-w-2xl mx-auto text-center space-y-8 relative">
        
        <!-- Bouton d'aide -->
        <button id="helpButton" class="absolute top-0 right-0 w-10 h-10 bg-gray-100 hover:bg-gray-200 rounded-full flex items-center justify-center text-gray-600 hover:text-gray-800 transition-colors">
            ?
        </button>
        
        <!-- Titre et sous-titre -->
        <div class="space-y-2">
            <h1 class="text-4xl font-bold">Traducteur Vocal</h1>
            <p class="text-gray-600">Parlez, nous traduisons</p>
        </div>
        
        <!-- Bouton d'enregistrement avec barre de progression circulaire -->
        <div class="space-y-4">
            <div class="relative flex items-center justify-center">
                <!-- Barre de progression circulaire -->
                <svg id="circularProgress" class="absolute w-28 h-28 transform -rotate-90 opacity-0 transition-opacity duration-300" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="45" stroke="#e5e7eb" stroke-width="2" fill="none"/>
                    <circle id="progressCircle" cx="50" cy="50" r="45" stroke="#000000" stroke-width="2" fill="none" 
                            stroke-dasharray="283" stroke-dashoffset="283" stroke-linecap="round"
                            style="transition: stroke-dashoffset 0.3s ease;"/>
                </svg>
                
                <!-- Bouton d'enregistrement -->
                <button id="recordButton" class="w-24 h-24 bg-black text-white rounded-full hover:bg-gray-700 transition-all duration-200 active:scale-95 flex items-center justify-center relative z-10">
                    <svg id="micIcon" width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2C10.34 2 9 3.34 9 5V11C9 12.66 10.34 14 12 14C13.66 14 15 12.66 15 11V5C15 3.34 13.66 2 12 2Z" fill="currentColor"/>
                        <path d="M19 10V11C19 15.42 15.42 19 11 19H13C17.42 19 21 15.42 21 11V10H19Z" fill="currentColor"/>
                        <path d="M5 10V11C5 15.42 8.58 19 13 19H11C6.58 19 3 15.42 3 11V10H5Z" fill="currentColor"/>
                        <path d="M12 22V19" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        <path d="M8 22H16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                    
                    <!-- Icône d'arrêt (cachée par défaut) -->
                    <svg id="stopIcon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="hidden">
                        <rect x="6" y="6" width="12" height="12" rx="2" fill="currentColor"/>
                    </svg>
                </button>
            </div>
            <p id="actionText" class="text-sm text-gray-500">Appuyer pour parler</p>
        </div>
        
        <!-- Zone de résultat -->
        <div id="resultArea" class="hidden space-y-4 p-6 border border-gray-200 rounded-lg bg-gray-50">
            <div id="originalText" class="text-sm text-gray-700"></div>
            <div class="flex items-center justify-between">
                <div id="translationResult" class="text-lg font-medium text-black flex-1"></div>
                <button id="audioPlayButton" class="ml-4 w-10 h-10 bg-gray-600 text-white rounded-full hover:bg-gray-700 transition-all duration-200 flex items-center justify-center hidden">
                    <!-- Icône Play -->
                    <svg id="playIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M8 5V19L19 12L8 5Z" fill="currentColor"/>
                    </svg>
                    <!-- Icône Pause (cachée par défaut) -->
                    <svg id="pauseIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="hidden">
                        <path d="M6 4H10V20H6V4Z" fill="currentColor"/>
                        <path d="M14 4H18V20H14V4Z" fill="currentColor"/>
                    </svg>
                </button>
            </div>
            <button id="resetButton" class="text-xs text-gray-500 hover:text-gray-800 transition-colors">Nouvelle traduction</button>
        </div>
        
    </div>
    
    <!-- Modal d'aide -->
    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-lg p-6 max-w-md w-full">
            <h3 class="text-lg font-medium text-gray-900 mb-4">Comment utiliser</h3>
            <div class="space-y-3 text-sm text-gray-600">
                <p>• Cliquez sur le bouton pour commencer l'enregistrement</p>
                <p>• Parlez clairement dans votre microphone</p>
                <p>• Cliquez à nouveau pour arrêter et traiter</p>
                <p>• La traduction apparaîtra automatiquement</p>
            </div>
            <button id="closeModal" class="mt-6 w-full bg-gray-900 text-white py-2 px-4 rounded hover:bg-gray-800 transition-colors">
                Compris
            </button>
        </div>
    </div>

    <script>
        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        
        const recordButton = document.getElementById('recordButton');
        const circularProgress = document.getElementById('circularProgress');
        const progressCircle = document.getElementById('progressCircle');
        const micIcon = document.getElementById('micIcon');
        const stopIcon = document.getElementById('stopIcon');
        const actionText = document.getElementById('actionText');
        const resultArea = document.getElementById('resultArea');
        const originalText = document.getElementById('originalText');
        const translationResult = document.getElementById('translationResult');
        const audioPlayButton = document.getElementById('audioPlayButton');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        
        let currentAudio = null;
        let isAudioPlaying = false;
        const resetButton = document.getElementById('resetButton');
        
        // Fonction pour mettre à jour la progression circulaire
        function updateCircularProgress(percentage) {
            const circumference = 2 * Math.PI * 45; // rayon = 45
            const offset = circumference - (percentage / 100) * circumference;
            progressCircle.style.strokeDashoffset = offset;
        }
        
        // Gestion de l'enregistrement
        recordButton.addEventListener('click', toggleRecording);
        resetButton.addEventListener('click', resetInterface);
        
        // Gestion de la modal d'aide
        const helpButton = document.getElementById('helpButton');
        const helpModal = document.getElementById('helpModal');
        const closeModal = document.getElementById('closeModal');
        
        helpButton.addEventListener('click', () => {
            helpModal.classList.remove('hidden');
        });
        
        closeModal.addEventListener('click', () => {
            helpModal.classList.add('hidden');
        });
        
        // Fermer la modal en cliquant à l'extérieur
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.classList.add('hidden');
            }
        });
        
        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        }
        
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = processRecordedAudio;
                
                mediaRecorder.start();
                isRecording = true;
                
                // Mise à jour de l'interface
                micIcon.classList.add('hidden');
                stopIcon.classList.remove('hidden');
                recordButton.classList.add('recording', 'bg-gray-600');
                recordButton.classList.remove('bg-gray-800');
                circularProgress.classList.remove('opacity-0');
                circularProgress.classList.add('opacity-100');
                actionText.textContent = 'Enregistrement en cours...';
                actionText.classList.remove('text-gray-500');
                actionText.classList.add('text-gray-700');
                updateCircularProgress(25);
                
            } catch (error) {
                console.error('Erreur d\'accès au microphone:', error);
                statusText.textContent = 'Erreur d\'accès au microphone';
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                
                // Mise à jour de l'interface
                stopIcon.classList.add('hidden');
                micIcon.classList.remove('hidden');
                recordButton.classList.remove('recording', 'bg-gray-600');
                recordButton.classList.add('bg-gray-800');
                actionText.textContent = 'Traitement en cours...';
                actionText.classList.remove('text-gray-700');
                actionText.classList.add('text-gray-600');
                updateCircularProgress(50);
            }
        }
        
        async function processRecordedAudio() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            
            try {
                updateCircularProgress(75);
                actionText.textContent = 'Analyse et traduction...';
                actionText.classList.remove('text-gray-600');
                actionText.classList.add('text-gray-700');
                
                // Conversion du blob audio en base64
                const reader = new FileReader();
                const audioBase64 = await new Promise((resolve) => {
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1]; // Enlever le préfixe data:audio/webm;base64,
                        resolve(base64);
                    };
                    reader.readAsDataURL(audioBlob);
                });
                
                const response = await fetch('/process_audio_llm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        audio_data: audioBase64
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Affichage des résultats
                    originalText.textContent = `Demande: "${result.original_text}"`;
                    translationResult.textContent = result.translated_text;
                    resultArea.classList.remove('hidden');
                    
                    // Configuration de la lecture audio
                    if (result.audio_data) {
                        setupAudioPlayback(result.audio_data);
                    }
                    
                    updateCircularProgress(100);
                    actionText.textContent = 'Traduction terminée';
                    actionText.classList.remove('text-gray-700');
                    actionText.classList.add('text-gray-800');
                    
                    // Réinitialisation après 2 secondes
                    setTimeout(() => {
                        updateCircularProgress(0);
                        circularProgress.classList.remove('opacity-100');
                        circularProgress.classList.add('opacity-0');
                        actionText.textContent = 'Appuyer pour parler';
                        actionText.classList.remove('text-gray-800');
                        actionText.classList.add('text-gray-500');
                    }, 2000);
                } else {
                    actionText.textContent = result.error || 'Erreur de traitement';
                    actionText.classList.remove('text-gray-700');
                    actionText.classList.add('text-gray-600');
                    updateCircularProgress(0);
                    circularProgress.classList.remove('opacity-100');
                    circularProgress.classList.add('opacity-0');
                    
                    // Retour au texte initial après 3 secondes
                    setTimeout(() => {
                        actionText.textContent = 'Appuyer pour parler';
                        actionText.classList.remove('text-gray-600');
                        actionText.classList.add('text-gray-500');
                    }, 3000);
                }
                
            } catch (error) {
                console.error('Erreur de traitement:', error);
                actionText.textContent = 'Erreur de connexion';
                actionText.classList.remove('text-gray-700');
                actionText.classList.add('text-gray-600');
                updateCircularProgress(0);
                circularProgress.classList.remove('opacity-100');
                circularProgress.classList.add('opacity-0');
                
                // Retour au texte initial après 3 secondes
                setTimeout(() => {
                    actionText.textContent = 'Appuyer pour parler';
                    actionText.classList.remove('text-gray-600');
                    actionText.classList.add('text-gray-500');
                }, 3000);
            }
        }
        
        function resetInterface() {
            resultArea.classList.add('hidden');
            updateCircularProgress(0);
            circularProgress.classList.remove('opacity-100');
            circularProgress.classList.add('opacity-0');
            actionText.textContent = 'Appuyer pour parler';
            actionText.className = 'text-sm text-gray-500';
            originalText.textContent = '';
            translationResult.textContent = '';
            
            // Arrêter et cacher le bouton audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            audioPlayButton.classList.add('hidden');
            isAudioPlaying = false;
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
        }
        
        function toggleAudioPlayback() {
            if (!currentAudio) return;
            
            if (isAudioPlaying) {
                currentAudio.pause();
                isAudioPlaying = false;
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            } else {
                currentAudio.play();
                isAudioPlaying = true;
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            }
        }
        
        function setupAudioPlayback(audioData) {
            // Créer l'élément audio avec les données base64
            const audioBlob = new Blob([Uint8Array.from(atob(audioData), c => c.charCodeAt(0))], { type: 'audio/mpeg' });
            const audioUrl = URL.createObjectURL(audioBlob);
            
            currentAudio = new Audio(audioUrl);
            
            // Événements audio
            currentAudio.addEventListener('ended', () => {
                isAudioPlaying = false;
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            });
            
            currentAudio.addEventListener('error', (e) => {
                console.error('Erreur de lecture audio:', e);
                audioPlayButton.classList.add('hidden');
            });
            
            // Afficher le bouton
            audioPlayButton.classList.remove('hidden');
        }
        
        // Événements
        audioPlayButton.addEventListener('click', toggleAudioPlayback);
    </script>
</body>
</html>